Contents
========

1. Introduction
2. Installation
3. Passcode generation algorithm
4. Demo (Screenshot!)

4. About PAM (short talk)
   More details about how PAM works        



1. Introduction
===============
A one-time password (OTP) is a password that is only valid for a
single login session or transaction (usually along a normal static
password). Using them reduces risks associated with login into your
system from unsecure (keylogged) workstations.

The otpasswd consists of a pam module and an user utility. With the
utility user manages his "state" file: creates his KEY, manages flags
and prints passcards with one-time passwords.

PAM module enables (for example) OpenSSH to do an authentication using
one-time password with the information from user state file.

Program is written in C (C99) and implements OTP as described in
"Perfect Paper Passwords" description of which can be found here
https://www.grc.com/ppp.htm Program also kind of extends this idea
with "salt".

Program is in development. In ChangeLog there's a list of things i'd
like to implement before publishing this as version 1.0.  Most of
features work currently (as of v0.1) but of course - it requires
tests. Think of this as a beta software.



2. Installation
===============
To enable OTP for your ssh you have to:
0. Have all required dependencies (with headers)
1. Install the package
2. Enable its use in /etc/pam.d
3. Configure ssh to use PAM.
4. Generate keys for user (and print at least one password card)

So.

0) Package required openssl and gmp libraries and cmake tool.
   All should be available in repository of your distribution.

1) Package can be installed using your distribution repository (hopefully),
or in a simple way:
$ ./build.sh

This will use cmake to build Makefiles, and then call make.
You can then copy two files, PAM module into /lib/security
and otpasswd password manager to /usr/bin.

Or, hopefully, type make install.

2) For exemplary PAM config see examples/otpasswd-auth.

PAM module supports following options:
enforced - disallow logon if user doesn't have generated key
	   instead of ignoring OTP.
nolock   - disable locking (can cause race conditions)
secure   - disallow usage of --dontSkip option (dontSkip works bad with
	   locking and can cause some security holes)
show     - always use passcodes (ignore user options)
noshow   - never show passcodes (ignore user options)

3) In /etc/ssh/sshd_config you should have the following two lines:
ChallengeResponseAuthentication yes
UsePAM yes

4) To generate key, and display first passcard as fast as possible (so
you won't loose ability to login in case you're configuring OTP
remotely) you can use:
$ otpasswd -k



3. Passcode generation algorithm
================================

The heart of the system is Rijndael (AES) cipher, which encrypts
128bit blocks with 256bit key; this operation generated 128bit of data
which is used  to calculate passcode.

Each user during key generation is equipped with this key and 128bit
passcode counter. When user authenticates or prints passcard, for each
passcode generated the corresponding counter value is encrypted with
key:

       |-------------|
       | 256 bit key |  
       |-------------|
             ||
             ||
             ||
            \||/
             \/
       /-------------\       \  |-----------------|
       |  Rijndael   | -------\ | Encrypted value |
       |   Cipher    | -------/ | 128 bits        |
       \-------------/       /  |-----------------|
             /\                          |
            /||\                         | Repeated division
             ||                          | by alphabet length.
             ||                        \ | /
             ||                         \./
     |-----------------|            /------------/ 
     | Salt  | counter |           /  Passcode  /
     | 96bit |  32bit  |          /------------/ 
     |-----------------|
              
This salt needs a bit of explanation. Genuine PPPv3 algorithms doesn't
use salt at all - counter is 128bit long. This allows to use over
3.4 * 10^38  passcodes, that is around 4.86 * 10^36 passcards. Nobody
needs that much and so this bits would be wasted. Also, an attacker which
would be able to keylog your authentication will know corresponding counter
value and to predict future passcodes he only lacks the key.

Many ciphers were vulnerable to, so called, known-plaintext
attacks. Rijndael -- as far as I know -- isn't but it doesn't mean
that in future such attack couldn't be discovered.

Closing this hole was easy. By generating additionaly 96bits of random
data and storing them inside counter value we make attacker impossible
task of breaking the key even more impossible. Also brute-force attack
on key will take a bit longer.

If you had 10^6 of 3GHz machines, being able to test one key in one
cycle... you could test 3*10^9*10^6 keys in a second. That would still
take you... 1.22 * 10^54 yeeeaaarrrsss. With salt that is more than
 10^82 years.



4. About PAM (short talk)
=========================
Most application which require password input check
the password using PAM. I'll stick to the sshd as an example.

SSH when user logs in tries to authenticate him using it's own
method - keys. Then, if this method fails it talks with PAM.
PAM to see how to authenticate sshd reads /etc/pam.d/sshd.

In default Gentoo installation it will contain following lines:
auth       include        system-remote-login
account    include        system-remote-login
password   include        system-remote-login
session    include        system-remote-login

This is line-oriented file in which each line tells us what to do.
We're interested in "auth" part only, which - includes configuration
from system-remote-login, which looks like this:
auth            include         system-login

And, as you can see, it just reads configuration from yet another file:
auth            required        pam_tally.so onerr=succeed
auth            required        pam_shells.so
auth            required        pam_nologin.so
auth            include         system-auth
(account, password, session omitted)

One more file (system-auth) to look into:
auth            required        pam_env.so
auth            required        pam_unix.so try_first_pass likeauth nullok


PAM when authenticating user will read the lines from top to bottom.
pam_tally - reads failures and can do some action according to them
pam_shells - checks if user has a valid shell (listed in /etc/shells)
pam_nologin - checks if logins were disabled (shows message)
pam_env - does something with environment
and finally:
pam_unix - checks password according to /etc/shadow

This is default schema and somewhere there we ought to add our OTP.

Easiest approach just modifies the first file: sshd. After all auth
entries we just add our pam_otpasswd module. File would look like:

auth            include         system-remote-login
# Line added for OTP:
auth            required        pam_otpasswd.so secure

account    include        system-remote-login
password   include        system-remote-login
session           include        system-remote-login

This will ask us for OTP after we are asked for our normal unix password
regardless if the unix password was correct or not. This can lead to Denial
of Service problem when attacker tries to login enough times to use up all
our printed passcards. If we have some other security mechanism (like
sshguard - which blocks sshd port for people who try the dictionary attacks)
it might be perfectly ok.

If not, we can change the line with pam_unix.so module from:
auth            required        pam_unix.so try_first_pass likeauth nullok
To:
auth            requisite       pam_unix.so try_first_pass likeauth nullok

Which will require correct unix password before asking OTP at all. If
we don't like to mess with global pam config files (system-auth etc.)
we can move all auth lines to sshd file, change this one line and add
pam_otpasswd line, which results in following configuration:

# Include commented out:
#auth       include        system-remote-login
# All auths included in sshd:
auth            required        pam_tally.so onerr=succeed
auth            required        pam_shells.so
auth            required        pam_nologin.so
auth            required        pam_env.so
auth            requisite       pam_unix.so try_first_pass likeauth nullok
# Our line:
auth            required        pam_otpasswd.so secure

#Rest
account    include        system-remote-login
password   include        system-remote-login
session           include        system-remote-login


This is exactly what is written in our examples/otpasswd-login file. You can
place this file in /etc/pam.d, and then edit your ssh to use it
in it's auth part:
auth       include        otpasswd-login
account    include        system-remote-login
password   include        system-remote-login
session    include        system-remote-login



5. Demo (Screenshot!)
=====================
Everybody loves it, so here is key generation, run by a user who
already has some key generated (and some flags toggled: 3-character
long passcodes, extended algorithm):

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Cirrus ~ % otpasswd -k
*****************************************************
* This will irreversibly erase your previous key    *
* making all already printed passcards worthless!   *
*****************************************************

Are you sure you want to continue? (yes/no): yes

Your current flags: show dont-skip alphabet-extended (key salted) codelength-3
Do you want to keep them? (yes/no): yes

Hint: Move your mouse, cause some disc activity
or type on keyboard to make the progress faster.

Gathering entropy... OK!

*****************************************************
* Print following passcard or at least make a note  *
* with a few first passcodes so you won't loose     *
* ability to log into your system!                  *
*****************************************************

Cirrus                          [1]
    A   B   C   D   E   F   G   H
 1: ZKU ;R2 k<N Cs@ 8aj K+/ 7U~ een
 2: 35p =k[ oCw Tp' ;sN t4i >v_ R-L
 3: !w, f%T +q~ M_b 9^3 KcA Po& $h<
 4: >vo %(R ak& UF( a|L Y~H A(b zbZ
 5: b,i O|, ?b+ VhS Y6F 95/ {\c %MG
 6: H/^ t_i Dye k3: 3Mq \7y vz[ +Wk
 7: (uU sa3 v\n [%c &5e [mE f"j pq^
 8: Es> ~pa wqo ?C[ !rL Y&O "[4 daT
 9: 'x: eE} YwU q|v eyy yp= ;y7 T\-
10: At! mFr GCC @dZ _$_ SeB ^4L |_w

Are you ready to start using one-time passwords? (yes/no): yes

Key stored!
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Example usage:
user@host $ ssh user@cirrus
Password: <user unix password>
Passcode B3 [1]: f%T

user@cirrus $

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
